<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/volatile关键字与java内存模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/volatile关键字与java内存模型/" itemprop="url">volatile关键字与java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-01T09:56:34+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>由volatile为切入点，串一串java并发的一些知识点</em></p>
<p>被volatile修饰的共享变量，具有了以下两点特性：</p>
<p>1 . 保证变量的内存可见性;</p>
<p>2 . 禁止指令重排序</p>
<p>涉及到的几个名词：</p>
<p>共享变量：代指实例域，静态域，数组元素；它们存储在堆内存里，堆内存在线程之间共享，会存在内存可见性问题</p>
<p>内存可见性、重排序：这个从Java内存模型（JMM）说起</p>
<h3 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h3><p>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，保存了该线程使用的变量的主内存副本。</p>
<p>线程只能直接操作本地内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<p>使用本地内存和主内存，虽然加快的速度，但是也带来了一些问题。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure>
<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，不一定是2，可能会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程1： load i from 主存    // i = 0</span><br><span class="line">        i + 1  // i = 1</span><br><span class="line">线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0</span><br><span class="line">        i +  1 //i = 1</span><br><span class="line">线程1:  save i to 主存</span><br><span class="line">线程2： save i to 主存</span><br></pre></td></tr></table></figure>
<p>如果两个线程按照上面的执行流程，那么i最后是1。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</p>
<p>JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p>
<h4 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h4><h5 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h5><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = 2;</span><br><span class="line">j = i;</span><br><span class="line">i++;</span><br><span class="line">i = i + 1;</span><br><span class="line">int n=6;</span><br></pre></td></tr></table></figure>
<p>上面4个操作中，</p>
<p><code>i=2</code>是读取操作，必定是原子性操作</p>
<p><code>j=i</code>其实分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作</p>
<p><code>i++</code>和<code>i = i + 1</code>其实是等效的，读取、操作、赋值3个操作。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。</p>
<p><code>int n=6</code>声明并赋值不是原子操作。①声明一个变量n ②给n赋值为6——这样就会有一个中间状态：变量n已经被声明了但是还没有被赋值的状态。</p>
<p>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p>
<p>JMM只实现了基本的原子性，像上面<code>i++</code>那样的操作，使用原子类或者<code>synchronized</code>来保证整块代码的原子性，线程在释放锁之前，必然会把<code>i</code>的值刷回到主存的。</p>
<h5 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h5><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li>volatile，当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</li>
<li>synchronized，线程在释放锁之前，，必须把变量值刷新回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
<h5 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h5><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，（单线程）程序的执行结果不能改变。比如下面的程序段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br></pre></td></tr></table></figure>
<p>上面的语句，可以按照<code>A-&gt;B-&gt;C</code>执行，结果为3.14,但是也可以按照<code>B-&gt;A-&gt;C</code>的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</p>
<p>比如这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程1            线程2</span><br><span class="line">flag = true；</span><br><span class="line">								</span><br><span class="line">								if(flag)</span><br><span class="line">								int ret = a*a;</span><br><span class="line">								</span><br><span class="line">a=2;</span><br></pre></td></tr></table></figure>
<p> 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</p>
<p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p>
<p>另外，JMM具备一些先天的<strong>有序性</strong>,即不需要通过任何手段就可以保证的有序性，通常称为<strong>happens-before</strong>原则。<code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code>定义了如下happens-before规则：</p>
<blockquote>
<ol>
<li><strong>单一线程规则(Single Thread rule)</strong>： 在一个线程内，在程序前面的操作先行发生于后面的操作</li>
<li><strong>监视器锁规则(Monitor Lock Rule)</strong>：对一个线程的解锁，先行发生于随后对同一个锁的加锁</li>
<li><strong>volatile变量规则（Volatile Variable Rule）</strong>： 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</li>
<li><strong>传递性</strong>：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li><strong>线程启动规则</strong>： 如果线程A执行操作<code>ThreadB_start()</code>(启动线程B) ,  那么A线程的<code>ThreadB_start()</code>happens-before 于B中的任意操作</li>
<li><strong>线程加入原则</strong>： 如果A执行<code>ThreadB.join()</code>并且成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</li>
<li><strong>线程中断原则</strong>： 对线程<code>interrupt()</code>方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测是否有中断发生</li>
<li><strong>finalize()原则</strong>：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始</li>
</ol>
</blockquote>
<p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
<p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
<p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
<p>第4条规则，就是happens-before的传递性。</p>
<p>后面几条就不再一一赘述了。</p>
<h3 id="理解volatile关键字"><a href="#理解volatile关键字" class="headerlink" title="理解volatile关键字"></a>理解volatile关键字</h3><h4 id="1-volatile保证可见性"><a href="#1-volatile保证可见性" class="headerlink" title="1.volatile保证可见性"></a>1.volatile保证可见性</h4><p><strong>volatile写-读的内存语义：</strong></p>
<p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</strong></p>
<p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong></p>
<p>再来看volatile建立的happens-before规则，也就是上面说的<strong>volatile变量规则</strong>：</p>
<p>继续拿上面的一段代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行<code>write</code>操作，线程2再执行<code>multiply</code>操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，<code>multiply</code>再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。</p>
<p>如果改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么线程1先执行<code>write</code>,线程2再执行<code>multiply</code>。根据happens-before原则，这个过程会满足以下3类规则：</p>
<ol>
<li>程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行)</li>
<li>volatile规则：2 happens-before 3</li>
<li>传递性规则：1 happens-before 4</li>
</ol>
<h4 id="2-volatile保证原子性吗"><a href="#2-volatile保证原子性吗" class="headerlink" title="2.volatile保证原子性吗"></a>2.volatile保证原子性吗</h4><p>对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作不可以。</p>
<p>比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
<p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
<p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
<p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p>
<p>有人说，<strong>volatile不是会使缓存行无效的吗</strong>？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p>
<p>又有人说，线程B将11写回主存，<strong>不会把线程A的缓存行设为无效吗</strong>？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
<p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p>
<p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h4 id="3-volatile保证有序性吗"><a href="#3-volatile保证有序性吗" class="headerlink" title="3.volatile保证有序性吗"></a>3.volatile保证有序性吗</h4><blockquote>
<p>若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序<br>volatile禁止指令重排序的一些规则：<br>　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序<br>　　2.当第一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序<br>　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</p>
</blockquote>
<p>也就是:<br>1.两个操作都有volatile的，一定不能重排序指令<br>2.后面如果是volatile写操作，则即便前面是普通写操作，为了保证主存数据是后面操作的结果，所以不能重排序<br>3.前面如果是volatile读操作，因为后面的普通写操作可能会刷新主存，为了保证百分百执行结果的正确，则也不能重排序</p>
<p>4.其他情况可以重排序指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，但是语句1和语句2的顺序是不作任何保证的。</p>
<h4 id="4-volatile的原理和实现机制"><a href="#4-volatile的原理和实现机制" class="headerlink" title="4.volatile的原理和实现机制"></a>4.volatile的原理和实现机制</h4><p>volatile到底如何保证可见性和禁止指令重排序的？</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h3 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h3><p>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。</p>
<p>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 </p>
<p>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 </p>
<p>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 </p>
<h3 id="volatile应用举例"><a href="#volatile应用举例" class="headerlink" title="volatile应用举例"></a>volatile应用举例</h3><ol>
<li>状态量标记：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p>
<p>2.单例模式的实现，典型的双重检查锁定（DCL）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两次if(instance==null)的判断，这个叫做『双重检查 Double-Check』。</p>
<ul>
<li>第一个 if(instance==null)，其实是为了解决代码二中的效率问题，只有instance为null的时候，才进入synchronized的代码段大大减少了几率。</li>
<li>第二个if(instance==null)，是为了防止可能出现多个实例的情况。</li>
</ul>
<p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。具体来说：</p>
<p>首先要理解<code>instance=new Singleton()</code>做了什么。<strong>创建一个对象</strong>有几个步骤:(整理自《java并发编程的艺术》)</p>
<p>1.检查类是否加载，如果没有先执行类加载过程（加载 验证 准备 解析 初始化）</p>
<p>2.为对象在堆中分配内存空间</p>
<p>3.成员变量进行默认初始化</p>
<p>4.调用构造函数，即把对象按照程序员的意愿初始化</p>
<p>5.返回地址给引用</p>
<p>而cpu为了优化程序，可能会进行指令重排序，打乱4,5的步骤，导致实例引用不为null但是仍没有完成初始化。这时候如果切换到线程B执行，发现引用不等于<code>null</code>，就可能导致线程B使用了还没有被初始化的变量，报错。</p>
<p>而instance加了volatile，则保证在写操作<code>instance = new Singleton();</code>完成之前，不会调用读操作<code>if(instance==null)</code></p>
<hr>
<p>参考：</p>
<p>《java并发编程的艺术》</p>
<p>《深入理解Java虚拟机》</p>
<p><a href="https://juejin.im/post/5a2b53b7f265da432a7b821c" target="_blank" rel="noopener">https://juejin.im/post/5a2b53b7f265da432a7b821c</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=_1-%E5%8E%9F%E5%AD%90%E6%80%A7" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=_1-%E5%8E%9F%E5%AD%90%E6%80%A7</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/理解synchronized关键字/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/理解synchronized关键字/" itemprop="url">理解synchronized关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-23T00:14:19+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 </p>
<p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程， 都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的 开销。 </p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th>具体分类</th>
<th>被锁住的对象</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">方法</td>
<td>实例方法</td>
<td>类的实例对象</td>
<td>public synchronized void method(){…}</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>静态方法</td>
<td>类对象</td>
<td>public static synchronized void method(){…}</td>
</tr>
<tr>
<td style="text-align:left">代码块</td>
<td>实例对象</td>
<td>类的实例对象</td>
<td>synchronized(this){…}</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>class对象</td>
<td>类对象</td>
<td>synchronized(类名.class){…}</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>任意实例对象</td>
<td>任意实例对象</td>
<td>String lock = “abc”;    synchronized(lock){…}</td>
</tr>
</tbody>
</table>
<ul>
<li>代码块上<ul>
<li>synchronized (this) {…} ，作用于一个对象</li>
<li>synchronized (类名.class) {…}， 作用于整个类</li>
</ul>
</li>
<li>方法上<ul>
<li>普通方法，作用于一个对象</li>
<li>静态方法，作用于整个类</li>
</ul>
</li>
</ul>
<ol>
<li>同步一个代码块(作用于同一个对象)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedExample &#123;</span><br><span class="line"></span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = new SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>同步一个方法(作用于同一个对象)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void func () &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它和同步代码块一样，作用于同一个对象。</p>
<ol start="3">
<li>同步一个类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void func() &#123;</span><br><span class="line">    synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedExample &#123;</span><br><span class="line"></span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        synchronized (SynchronizedExample.class) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SynchronizedExample e1 = new SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = new SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line">Copy to clipboardErrorCopied</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>同步一个静态方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized static void fun() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用于整个类。</p>
<p>最大的特征就是在同一时刻只有一个线程能够获得对象的监视器（monitor），从而进入到同步代码块或者同步方法之中，即表现为<strong>互斥性（排它性）</strong></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>synchronized 关键字底层原理属于 JVM 层面。</p>
<p>synchronized 同步语句块的实现<strong>使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图<strong>获取锁也就是获取 monitor</strong>的持有权(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) .当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<br>ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是:无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated），他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p>
<p><img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" alt="img"></p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p>
<p><img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/051e436c-0e46-4c59-8f67-52d89d656182.png" alt="img"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p>
<p>偏向锁的思想是偏向于让<code>第一个获取锁对象的线程</code>，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作<code>将线程 ID 记录到 Mark Word 中</code>，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></p>
<p>轻量级锁是相对于传统的重量级锁而言，它使用 <code>CAS 操作</code>来避免重量级锁使用<code>互斥量</code>的开销。对于<code>绝大部分的锁，在整个同步周期内都是不存在竞争的</code>，如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p>如果 CAS 操作失败了，虚拟机首先会检查<code>对象的 Mark Word 是否指向当前线程的虚拟机栈</code>，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。<code>如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁</code>。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>互斥同步进入阻塞状态的开销很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是<strong>让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</strong>。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于<strong>共享数据的锁定状态很短</strong>的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<p>锁消除主要是通过<code>逃逸分析</code>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一系列的连续操作都<code>对同一个对象反复加锁和解锁</code>，频繁的加锁操作就会导致性能损耗。</p>
<p>下面代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围<code>粗化到整个操作序列的外部</code>。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronized和ReenTrantLock-的区别"><a href="#synchronized和ReenTrantLock-的区别" class="headerlink" title="synchronized和ReenTrantLock 的区别"></a>synchronized和ReenTrantLock 的区别</h2><p><strong>1 两者都是可重入锁</strong> </p>
<p>两者都是可重入锁。“可重入锁”概念是:自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死 锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。 </p>
<p><strong>2 锁的实现</strong></p>
<p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<p><strong>3 ReenTrantLock 比 synchronized 增加了一些高级功能</strong> </p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点:1等待可中断;2可实现公平锁; 3可实现选择性通知(锁可以绑定多个条件) </p>
<p><strong>等待可中断</strong></p>
<p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
<p>ReentrantLock 可中断，而 synchronized 不行。</p>
<p><strong>公平锁</strong></p>
<p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<p><strong>锁绑定多个条件</strong></p>
<p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<p>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类实现是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例(即对象监视器)，线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知”，而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果 执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 </p>
<p>如果想使用上述功能，那么选择ReenTrantLock是一个不错的选择。 </p>
<p><strong>4 性能</strong></p>
<p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/HashMap源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/HashMap源码分析/" itemprop="url">HashMap源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T21:52:55+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>HashMap 通过 key 的 hashCode 经 过扰动函数处理过后得到 hash 值，然后通过判断当前元素存放的位置(这里的 n 指的是数组的 长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用扰动函数之后可以减少碰撞。</strong></p>
<p>HashMap 底层是基于数组和链表实现的。其中有两个重要的参数：</p>
<ul>
<li>容量</li>
<li>负载因子</li>
</ul>
<p>容量的默认大小是 16，负载因子是 0.75，当 HashMap 的 size &gt; 16*0.75 时就会发生扩容</p>
<p>JDK 1.8 HashMap源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//实现了Map&lt;K,V&gt;, Cloneable, Serializable接口。</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    //默认容量16，必须是2的次幂</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">    //最大容量 2的30次方</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    //默认的负载因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h4 id="扰动函数hash"><a href="#扰动函数hash" class="headerlink" title="扰动函数hash()"></a>扰动函数hash()</h4><blockquote>
<p>根据key的hash值寻找对应的哈希桶<code>[hash值 &amp; 哈希桶的长度-1]</code></p>
</blockquote>
<p>因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞几率是很小的。<br>但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，得到的index相同的情况的几率会大大增加，这种情况称之为hash碰撞。 </p>
<p>扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，<code>相当于高低位一起参与了运算</code>，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表节点Node"><a href="#链表节点Node" class="headerlink" title="链表节点Node"></a>链表节点Node</h4><p>Node 的核心组成其实也是和 jdk1.7 中的 Entry 一样，存储着键值对。它包含了四个字段 <code>key value hashcode next</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//哈希值</span></span><br><span class="line">    <span class="keyword">final</span> K key;    <span class="comment">//key</span></span><br><span class="line">    V value;        <span class="comment">//value</span></span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">//链表后置节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一个节点的hash值，是将key的hashCode 和 value的hashCode 异或得到的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置新的value 同时返回旧value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>HashMap有4个构造器,如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>
<p>initialCapacity默认为16，loadFactory默认为0.75</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* ---------------- Fields -------------- */</span><br><span class="line"></span><br><span class="line"> //table（哈希桶），存放链表（Node数组）该表在首次使用时初始化，并在必要时扩容；length总是2的次方，或者初始化时为0</span><br><span class="line"> transient Node&lt;K,V&gt;[] table;</span><br><span class="line"> //键值对的个数</span><br><span class="line"> transient int size;</span><br><span class="line"></span><br><span class="line"> //元素数量的阈值，当哈希表内元素数量超过阈值时，会发生扩容resize(capacity * load factor)</span><br><span class="line"> int threshold;</span><br><span class="line"></span><br><span class="line"> //负载因子，用于计算阈值。threshold = 哈希桶.length * loadFactor</span><br><span class="line"> final float loadFactor;</span><br><span class="line"></span><br><span class="line"> /* ---------------- Public operations -------------- */</span><br><span class="line"></span><br><span class="line"> //同时指定初始化容量以及加载因子。用的很少，一般不会修改loadFactor</span><br><span class="line"> public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //指定初始化容量的构造函数</span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">     this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //默认构造函数，赋值加载因子为默认的0.75f</span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //新建一个哈希表，同时将另一个map里的所有元素加入表中</span><br><span class="line"> public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩容resize"><a href="#扩容resize" class="headerlink" title="扩容resize()"></a>扩容resize()</h4><p>HashMap的扩容机制就是重新申请一个容量是当前的2倍的桶数组，然后将原先的记录逐个重新映射到新的桶里面。 </p>
<p>因为我们的length总是2的n次幂，所以在一次resize之后，当前位置的记录要么保持当前index不变，要么index+length就可以了</p>
<h5 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h5><p>长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于hash后几位的值。只要输入的hash本身分布均匀，index就是均匀的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        //oldTab 为当前表的哈希桶</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前哈希桶的容量</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">		</span><br><span class="line">        //如果当前表不空</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            //如果当前容量到达上限,设置阈值是2的31次方-1,不再扩容</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;                </span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;//否则新的容量为旧的容量的两倍。 </span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//如果旧的容量大于等于默认初始容量16</span><br><span class="line">                //那么新的阈值也等于旧的阈值的两倍</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">		//如果当前表是空，但有阈值</span><br><span class="line">        else if (oldThr &gt; 0) </span><br><span class="line">            newCap = oldThr;//新表容量就等于旧阈值</span><br><span class="line">        //如果当前表是空，且没有阈值</span><br><span class="line">		else &#123;               </span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;//新表容量为默认容量16</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值为默认阈值</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123;//如果新的阈值是0，对应的是  当前表是空，但有阈值的情况</span><br><span class="line">            float ft = (float)newCap * loadFactor;//根据新表容量 和 加载因子 求出新的阈值</span><br><span class="line">            //进行越界修复</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        //更新阈值 </span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        //根据新的容量 构建新的哈希桶</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line"></span><br><span class="line">        //下面开始将老的哈希桶中的所有节点转移到新哈希桶中</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            //遍历老的哈希桶</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;               </span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    //将原哈希桶置空以便GC</span><br><span class="line">                    oldTab[j] = null;</span><br><span class="line">                    //如果只有一个元素，直接加入新桶，下标为[哈希值&amp;桶的长度-1]</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    //如果是红黑树</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    //如果是链表。要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</span><br><span class="line">                    else &#123; </span><br><span class="line">                        //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位=  low位+原哈希桶容量</span><br><span class="line">                        //低位链表的头结点、尾节点</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        //高位链表的头节点、尾节点</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            //这里又是一个利用位运算 代替常规运算的高效点： 利用（哈希值&amp;旧桶容量），等于0代表小于oldCap，放在低位，否则放在高位</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123; </span><br><span class="line">                                //给头尾节点指针赋值</span><br><span class="line">                                if (loTail == null)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;//高位也是相同的逻辑</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        //将低位链表存放在原index处，</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //将高位链表存放在新index处</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br></pre></td></tr></table></figure>
<h4 id="增：put-key-value"><a href="#增：put-key-value" class="headerlink" title="增：put(key,value)"></a>增：put(key,value)</h4><p>hashcode–&gt;hash–&gt;index:  (hash&amp;length-1)</p>
<ol>
<li>判断当前桶是否为空，空的就需要初始化。</li>
<li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li>
<li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就找到了要覆盖的节点e</li>
<li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li>
<li>如果是个链表，遍历链表找到要覆盖的节点e，接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                  boolean evict) &#123;</span><br><span class="line">       //tab存放 当前的哈希桶， p用作临时链表节点  </span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">       //如果当前哈希表是空的，代表是初始化;直接扩容</span><br><span class="line">       if ((tab = table) == null || (n = tab.length) == 0)           </span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       //如果当前index的节点是空，构建一个新节点Node，放在index处：[hash值 &amp; 哈希桶的长度-1]，替代模运算</span><br><span class="line">       if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">           tab[i] = newNode(hash, key, value, null);</span><br><span class="line">       else &#123;//否则 发生了哈希冲突。           </span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           //如果哈希值相等，key也相等，覆盖value</span><br><span class="line">           if (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;//将当前节点引用赋值给e</span><br><span class="line">           else if (p instanceof TreeNode)//红黑树</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">           else &#123;//不是覆盖操作，则插入一个普通链表节点</span><br><span class="line">               //遍历链表</span><br><span class="line">               for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                   //遍历到尾部，追加新节点到尾部;节点数量&gt;=8，则转化为红黑树</span><br><span class="line">				if ((e = p.next) == null) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, null);</span><br><span class="line">                       if (binCount &gt;= TREEIFY_THRESHOLD - 1) </span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //如果找到了要覆盖的节点</span><br><span class="line">                   if (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                       break;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //如果e不是null，说明有需要覆盖的节点</span><br><span class="line">           if (e != null) &#123; </span><br><span class="line">               //则覆盖节点值，并返回原oldValue</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               return oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span><br><span class="line">       //修改modCount</span><br><span class="line">       ++modCount;</span><br><span class="line">       //更新size，并判断是否需要扩容。</span><br><span class="line">       if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       //这是一个空实现的函数，用作LinkedHashMap重写使用。</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="查：get-key"><a href="#查：get-key" class="headerlink" title="查：get(key)"></a>查：get(key)</h4><p>以key为条件，找到返回value。没找到返回null</p>
<p>查找简单来说需要分成两步进行：</p>
<ol>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ol>
<p>具体来说：</p>
<ol>
<li>首先将 key hash 之后取得所定位的桶。</li>
<li>如果桶为空则直接返回 null 。</li>
<li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。（always check first node）</li>
<li>如果第一个不匹配，则判断它的下一个是红黑树还是链表；红黑树就按照树的查找方式返回值；不然就按照链表的方式遍历匹配返回值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传入hash值和key找到目标节点Node</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    //查找过程和删除基本差不多， 找到返回节点，否则返回null</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删-remove-key"><a href="#删-remove-key" class="headerlink" title="删: remove(key)"></a>删: remove(key)</h4><ul>
<li>以key为条件删除:如果key对应的value存在，则删除这个键值对。 并返回value。如果不存在 返回null</li>
<li>以key value 为条件删除:必须key 、value都相等才删除</li>
</ul>
<p>查找过程和删除基本差不多， 找到返回节点，否则返回null</p>
<h3 id="与-HashTable-的比较"><a href="#与-HashTable-的比较" class="headerlink" title="与 HashTable 的比较"></a>与 HashTable 的比较</h3><ol>
<li>HashTable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ol>
<h3 id="HashMap并发使用的问题"><a href="#HashMap并发使用的问题" class="headerlink" title="HashMap并发使用的问题"></a>HashMap并发使用的问题</h3><ul>
<li>数据丢失</li>
<li>数据重复</li>
<li>死循环</li>
</ul>
<p>1、put的时候导致数据丢失。</p>
<p>两个线程在同一个位置添加数据，后面添加的数据就覆盖住了前面添加的。</p>
<p> 2、如果有两个线程同时发现自己都key不存在，且两个线程的key实际是相同的，<br>在向链表中写入的时候第一线程将e设置为了自己的Entry,而第二个线程执行到了e.next，依然会将自己持有是数据插入到链表中，这样就出现了数据重复。</p>
<p> 3、死循环</p>
<p> （主要还是在于对于链表对倒序处理（头插法），在Java 8中，已经不在使用倒序链表，死循环问题得到了极大改善）</p>
<ul>
<li><p>举个例子解释一下死循环的出现原因：</p>
<p>扩容的时候，并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p>
</li>
</ul>
<p> 举例说明：</p>
<p>假如转移前链表顺序是3-&gt;7-&gt;5，那么转移后就会变成5-&gt;3-&gt;7 </p>
<p> 假设这里有两个线程同时执行了put()操作，并resize</p>
<p> 如图，线程1的 e 指向了 key(3)，而 next 指向了 key(7)，在线程2 rehash 后，就指向了线程2 rehash 后的链表。</p>
<p> <img src="https://i.loli.net/2019/03/21/5c930a853fd38.png" alt="resize1"></p>
<p> 然后线程1被唤醒了：</p>
<p>key(3)的 next 指向了线程1的新 Hash 表<br>线程1的新 Hash 表第一个元素指向了 key(3)。好了，e 处理完毕。<br>然后执行 key(3)的 next 节点 key(7)，头部变成 key(7)</p>
<p><img src="https://i.loli.net/2019/03/21/5c930e9963f0d.png" alt="resize2.png"></p>
<p>然后执行 key(7)的 next 节点 key(3)，头部变成 key(3)，key(3) 的 next 就成了 key(7)，环形链表出现了</p>
<p><img src="https://i.loli.net/2019/03/21/5c930ecf3673d.png" alt="resize3.png"></p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>建议用<code>EntrySet</code>进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; next = it.next();</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*    </span></span><br><span class="line"><span class="comment">   for(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       System.out.println("key= "+entry.getKey()+" and value= "+entry.getValue());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<p>## </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/上传文件到OSS/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/15/上传文件到OSS/" itemprop="url">上传文件到OSS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T21:54:05+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实习时遇到的需求：把数据导出并以csv文件的形式上传到OSS（阿里云对象存储服务（Object Storage Service，简称 OSS））上。下面简单总结一下</p>
<p>首先明确几点：</p>
<ul>
<li><p>创建了存储空间（Bucket）之后，可以上传任何类型的文件（Object）到存储空间中。</p>
</li>
<li><p>上传Object一般使用putObject或者multipartUpload函数。<br>在OSS中严格来说是没有文件夹的概念的，在管理控制台看到的文件夹是为了方便管理以文件夹的方式显示出来。实际上只是 abc/efg/123.jpg 这个路径的Object，以 / 为分隔符隔开放置。</p>
</li>
<li><p>简单上传分为流式上传和文件上传。流式上传使用InputStream作为文件的数据源。文件上传使用本地文件作为OSS文件的数据源。</p>
</li>
</ul>
<p>代码如下（重要信息已隐藏）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliOSSUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String END_POINT = <span class="string">"xxxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ACCESS_KEY_ID = <span class="string">"xxxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ACCESS_KEY_SECRET = <span class="string">"xxxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String BUCKET_NAME = <span class="string">"xxxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法描述:上传文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upload</span><span class="params">(File file, String objName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建OSS客户端</span></span><br><span class="line">        OSSClient ossClient = <span class="keyword">new</span> OSSClient(END_POINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断文件容器是否存在，不存在则创建</span></span><br><span class="line">            <span class="keyword">if</span> (!ossClient.doesBucketExist(BUCKET_NAME)) &#123;</span><br><span class="line">                ossClient.createBucket(BUCKET_NAME);</span><br><span class="line">                CreateBucketRequest createBucketRequest = <span class="keyword">new</span> CreateBucketRequest(BUCKET_NAME);</span><br><span class="line">                createBucketRequest.setCannedACL(CannedAccessControlList.PublicRead);</span><br><span class="line">                ossClient.createBucket(createBucketRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建文件路径</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上传文件</span></span><br><span class="line">            PutObjectResult result = ossClient.putObject(<span class="keyword">new</span> PutObjectRequest(BUCKET_NAME, objName, file));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">                <span class="comment">//return FILE_HOST + fileUrl;</span></span><br><span class="line">                <span class="comment">// 设置这个文件地址的有效时间</span></span><br><span class="line">                Date expiration = <span class="keyword">new</span> Date(<span class="keyword">new</span> Date().getTime() + <span class="number">3600l</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">10</span>);</span><br><span class="line">                String url = ossClient.generatePresignedUrl(BUCKET_NAME, objName, expiration).toString();</span><br><span class="line">                <span class="keyword">return</span> url;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            log.error(oe.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            log.error(ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭OSS服务，一定要关闭</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法描述:上传文件流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream 文件流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upload</span><span class="params">(InputStream inputStream, String objName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建OSS客户端</span></span><br><span class="line">        OSSClient ossClient = <span class="keyword">new</span> OSSClient(END_POINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断文件容器是否存在，不存在则创建</span></span><br><span class="line">            <span class="keyword">if</span> (!ossClient.doesBucketExist(BUCKET_NAME)) &#123;</span><br><span class="line">                ossClient.createBucket(BUCKET_NAME);</span><br><span class="line">                CreateBucketRequest createBucketRequest = <span class="keyword">new</span> CreateBucketRequest(BUCKET_NAME);</span><br><span class="line">                createBucketRequest.setCannedACL(CannedAccessControlList.PublicRead);</span><br><span class="line">                ossClient.createBucket(createBucketRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上传文件</span></span><br><span class="line">            PutObjectResult result = ossClient.putObject(<span class="keyword">new</span> PutObjectRequest(BUCKET_NAME, objName, inputStream));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != result) &#123;</span><br><span class="line">                <span class="comment">// 设置这个文件地址的有效时间</span></span><br><span class="line">                Date expiration = <span class="keyword">new</span> Date(<span class="keyword">new</span> Date().getTime() + <span class="number">3600l</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">10</span>);</span><br><span class="line">                String url = ossClient.generatePresignedUrl(BUCKET_NAME, objName, expiration).toString();</span><br><span class="line">                <span class="keyword">return</span> url;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            log.error(oe.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            log.error(ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭OSS服务，一定要关闭</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objName 需要被下载的文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">download</span><span class="params">(String objName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSSClient ossClient = <span class="keyword">new</span> OSSClient(END_POINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET);</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer bf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String down = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ossObject包含文件所在的存储空间名称、文件名称、文件元信息以及一个输入流。</span></span><br><span class="line">            OSSObject ossObject = ossClient.getObject(BUCKET_NAME, objName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件内容。</span></span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(ossObject.getObjectContent()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                bf.append(<span class="string">"\r\n"</span> + line);</span><br><span class="line">                <span class="comment">//System.out.println("\n" + line);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//return down;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            log.error(oe.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            log.error(ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭OSS服务</span></span><br><span class="line">            ossClient.shutdown();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>)</span><br><span class="line">                    reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读取关闭失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> down;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/11/谈一谈令人疑惑的String类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/11/谈一谈令人疑惑的String类/" itemprop="url">谈一谈令人疑惑的String类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-11T21:54:22+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="String对象不可变"><a href="#String对象不可变" class="headerlink" title="String对象不可变"></a>String对象不可变</h3><p>String使用<code>private final char value[]</code>来实现字符串的存储，也就是说String对象创建之后，就不能再修改此对象中存储的字符串内容，就是因为如此，才说String类型是不可变的(immutable)。程序员不能对已有的不可变对象进行修改。我们自己也可以创建不可变对象，只要在接口中<code>不提供修改数据的方法</code>就可以。</p>
<p>然而，String类对象确实有编辑字符串的功能，比如replace()。这些编辑功能是通过<code>创建一个新的对象</code>来实现的，而不是对原有对象进行修改。比如:<br><code>s = s.replace(&quot;World&quot;, &quot;Universe&quot;);</code><br>上面对s.replace()的调用将创建一个新的字符串”Hello Universe!”，并返回该对象的引用。引用s将指向该新的字符串。如果没有其他引用指向原有字符串”Hello World!”，原字符串对象将被垃圾回收。</p>
<blockquote>
<p>String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</p>
</blockquote>
<ul>
<li>一个问题：<br>String s = new String(“abc”) 涉及到几个对象？</li>
</ul>
<p>常量池中没有“abc”字面量，则创建两个对象（字符串池中一个，堆中一个），否则创建一个对象.</p>
<h3 id="关于equals和"><a href="#关于equals和" class="headerlink" title="关于equals和=="></a>关于equals和==</h3><p>（1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的”值”是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。</p>
<p>（2）equals方法是基类Object中的方法。在Object类中，equals方法是用来比较两个对象的引用是否相等（即是否指向同一个对象）。</p>
<p>（3）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类，还有Double，Date，Integer等都对equals方法进行了重写，用来比较指向的对象对象所存储的内容串是否相等。</p>
<h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 编译期确定</span><br><span class="line"> */</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    String s0=&quot;helloworld&quot;;</span><br><span class="line">    String s1=&quot;helloworld&quot;;</span><br><span class="line">    String s2=&quot;hello&quot;+&quot;world&quot;;</span><br><span class="line">    System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 </span><br><span class="line">    System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：因为例子中的s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true；</p>
<p>当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出<code>s0==s1==s2</code></p>
<hr>
<p>字符串拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 比较字符串常量的“+”和字符串引用的“+”的区别</span><br><span class="line"> */</span><br><span class="line">以下代码：</span><br><span class="line">    String s1 = &quot;Hollis&quot;;</span><br><span class="line">    String s2 = &quot;Chuang&quot;;</span><br><span class="line">    String s3 = s1 + s2;</span><br><span class="line">    String s4 = &quot;Hollis&quot; + &quot;Chuang&quot;;</span><br><span class="line">    System.out.println(s3==&quot;HollisChuang&quot;); //false</span><br><span class="line">    System.out.println(s4==&quot;HollisChuang&quot;); //true</span><br><span class="line">    </span><br><span class="line">在经过反编译后，得到代码如下：</span><br><span class="line">    String s1 = &quot;Hollis&quot;;</span><br><span class="line">    String s2 = &quot;Chuang&quot;;</span><br><span class="line">    String s3 = (new StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">    String s4 = &quot;HollisChuang&quot;;</span><br></pre></td></tr></table></figure>
<p>可以发现，同样是字符串拼接，s3和s4在经过编译器编译后的实现方式并不一样。s3被转化成StringBuilder及append，而s4被直接拼接成新的字符串。</p>
<p>其实，String s4 = s1 + s2; 经过编译之后，常量池中是有两个字符串常量的分别是 Hollis、Chuang，拼接结果HollisChuang并不在常量池中。</p>
<p>如果代码只有String s4 = “Hollis” + “Chuang”;，那么常量池中将只有HollisChuang而没有Hollis和 Chuang。<br><code>String s4 = &quot;Hollis&quot; + &quot;Chuang&quot;</code>等价于<code>String s4 = &quot;HollisChuang&quot;</code>。<br><code>字符串字面量拼接操作是在Java编译器编译期间就执行了</code>，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将多个字面量合成一个，避免了创建多余的字符串对象。</p>
<p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成StringBuilder.append，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 编译期无法确定</span><br><span class="line"> */</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    String s0=&quot;helloworld&quot;; </span><br><span class="line">    String s1=new String(&quot;helloworld&quot;); </span><br><span class="line">    String s2=&quot;hello&quot; + new String(&quot;world&quot;); </span><br><span class="line">    System.out.println(&quot;===========test4============&quot;);</span><br><span class="line">    System.out.println( s0==s1 ); //false  </span><br><span class="line">    System.out.println( s0==s2 ); //false </span><br><span class="line">    System.out.println( s1==s2 ); //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码，结果为：false、false、false。</p>
<p>分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，<code>它们有自己的地址空间</code>。</p>
<p>s0还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用。</p>
<h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>（1）可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。</p>
<p>StringBuffer、StringBuilder的区别（线程安全和效率）</p>
<p>（2）是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的。</p>
<p>（3）String、StringBuilder、StringBuffer三者的执行效率：<br>StringBuilder &gt; StringBuffer &gt; String （相对而言）<br>当字符串相加操作或者改动较少的情况下，建议使用 String；<br>当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。</p>
<h4 id="为什么StringBuilder更快？"><a href="#为什么StringBuilder更快？" class="headerlink" title="为什么StringBuilder更快？"></a>为什么StringBuilder更快？</h4><ul>
<li>为什么StringBuilder比String快？</li>
</ul>
<p>StringBuilder对字符串的操作只在一个实例上进行修改，达到节约系统开销的目的，而String具有不可变性，一切对string类型的操作都会申请一块新的内存产生新的字符串。可能一般影响不大，但大量的字符串操作，如在循环体中，造成的系统开销是不能忽视的。</p>
<ul>
<li>为什么StringBuilder比StringBuffer快？</li>
</ul>
<p>看一下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//java.lang.StringBuilder</span><br><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//java.lang.StringBuffer</span><br><span class="line">public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer类的append()方法，被synchronized所修饰。有加锁开销，效率略低</p>
<p>参考：</p>
<p><a href="https://note.youdao.com/" target="_blank" rel="noopener">深入理解Java中的String</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/IO流/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/IO流/" itemprop="url">IO流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-09T15:06:41+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java对数据的操作是通过流的方式，用于操作流的对象都在IO包中</p>
<ul>
<li>流按操作数据分为两种：字节流与字符流（处理文字数据）</li>
<li>流按流向分为：输入流，输出流</li>
<li><p>字节流的抽象基类： InputStream ，OutputStream</p>
<pre><code>FileInputStream, FileOnputStream,
BufferedInputStream, BufferedOnputStream
</code></pre></li>
<li><p>字符流的抽象基类： Reader ， Writer </p>
<pre><code>FileReader, FileWriter
BufferedReader, BufferedWriter
</code></pre></li>
</ul>
<blockquote>
<p>把握几点：</p>
</blockquote>
<ul>
<li>流是用来处理数据的。</li>
<li>处理数据时，一定要先明确数据源，与数据目的地</li>
<li>数据源可以是文件，键盘。</li>
<li>数据目的地可以是文件，显示器或者其他设备。</li>
<li>而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理.转换处理等</li>
</ul>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><blockquote>
<p>写：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>; <span class="comment">//在外面建立引用;在try内初始化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//FileWriter对象一被初始化就要明确被操作的文件</span></span><br><span class="line">            <span class="comment">//文件被创建在指定目录下,如果存在同名文件将被覆盖</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用write方法,把数据写入到流中</span></span><br><span class="line">            fw.write(<span class="string">"abcde"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//刷新流对象中缓冲中的数据,将数据刷到目的地</span></span><br><span class="line">            <span class="comment">//fw.flush();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭流资源,关闭前会刷新一次内部缓冲;</span></span><br><span class="line">            <span class="comment">//和flush区别:flush刷新后流可以继续使用,close刷新后,流关闭</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fw != <span class="keyword">null</span>) <span class="comment">//不为空才需要关闭(如果有多个,要一个个关闭)</span></span><br><span class="line">                    fw.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>续写：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递true参数,代表不覆盖已有文件,并在末尾处续写数据</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>, <span class="keyword">true</span>);</span><br><span class="line">    fw.write(<span class="string">"nihao\r\nxiexie"</span>);</span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//创建文件读取流对象,和指定文件相关联</span></span><br><span class="line">        <span class="comment">//保证文件,存在,否则发生异常FileNotFoundException</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个数组,存储读到的字符</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read方法,读到的内容放数组里,返回的是读到的字符个数</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(buf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fr.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件复制:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"sysdemo_copy.txt"</span>);</span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(<span class="string">"sysdemo.java"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len=fr.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fw.write(buf,<span class="number">0</span>,len); <span class="comment">//把数组中的数据写入流</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(fw!=<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流的缓冲区"><a href="#字符流的缓冲区" class="headerlink" title="字符流的缓冲区"></a>字符流的缓冲区</h3><p> 缓冲区的出现提高了对数据的读写效率。<br> 对应类 BufferedWriter，BufferedReader。缓冲区要结合流才可以使用，在流的基础上对流的功能进行了增强。</p>
<p> 这是装饰设计模式的体现（比继承更灵活，避免集成体系臃肿）</p>
<p> 缓冲区提供了一个跨平台方法 newLine（）,换行（因为Windows里是\r\n，linux里是\n）</p>
<p> readLine方法，读取一行数据，不返回回车符(其原理依然是read方法一次读一个的方法，相当于把换行符之前的数据先暂存，比read方法高效)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextByBuf</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">       BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"sysdemo.java"</span>));</span><br><span class="line">           bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"sysdemo_copy.txt"</span>));</span><br><span class="line">           String line = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> ((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               bufw.write(line);</span><br><span class="line">               bufw.newLine();</span><br><span class="line">               bufw.flush();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span>(bufr!=<span class="keyword">null</span>)</span><br><span class="line">                       bufr.close();</span><br><span class="line">               &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读取关闭失败"</span>);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span>(bufw!=<span class="keyword">null</span>)</span><br><span class="line">                       bufw.close();</span><br><span class="line">               &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"写入关闭失败"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p> 想要操作图片数据，就要用到字节流</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);</span><br><span class="line">        fos.write(<span class="string">"abcde"</span>.getBytes());  <span class="comment">//写入字节</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取转换流"><a href="#读取转换流" class="headerlink" title="读取转换流"></a>读取转换流</h3><p> InputStreamReader,OutputStreamWriter(构造时可以加入字符集)</p>
<p>转换流的由来</p>
<ul>
<li>字符流与字节流之间的桥梁</li>
<li><p>方便了字符流与字节流之间的操作</p>
<p>转换流的应用：字节流中的数据都是字符时，转成字符流操作<br>更高效。</p>
</li>
</ul>
<p>例程:标准输入输出</p>
<p>标准输入输出流</p>
<ul>
<li>System类中的字段:in，out。</li>
<li>它们各代表了系统标准的输入和输出设备。</li>
<li>默认输入设备是键盘，输出设备是显示器。（键盘录入的结束：ctr+c或者自定义）</li>
<li>System.in的类型是InputStream.</li>
<li>System.out的类型是PrintStream是 OutputStream的子类FilterOutputStream 的子类.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//获取键盘录入对象</span></span><br><span class="line">        <span class="comment">//InputStream in = System.in;</span></span><br><span class="line">        <span class="comment">//将字节流对象转成字符流对象,使用转换流 InputStreamReader</span></span><br><span class="line">        <span class="comment">//InputStreamReader isr = new InputStreamReader(in);</span></span><br><span class="line">        <span class="comment">//使用缓冲区提高效率</span></span><br><span class="line">        <span class="comment">//BufferedReader bufr = new BufferedReader(isr);</span></span><br><span class="line"></span><br><span class="line">        BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); <span class="comment">//键盘录入最常见写法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//OutputStream out = System.out;</span></span><br><span class="line">        <span class="comment">//OutputStreamWriter osw = new OutputStreamWriter(out);</span></span><br><span class="line">        <span class="comment">//BufferedWriter bufw = new BufferedWriter(osw); //使用缓冲区可以用newline方法</span></span><br><span class="line"></span><br><span class="line">        BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"over"</span>.equals(line)) <span class="comment">//自定义结束录入标志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            bufw.write(line.toUpperCase());</span><br><span class="line">            bufw.newLine();</span><br><span class="line">            bufw.flush(); <span class="comment">//一定要flush</span></span><br><span class="line">        &#125;</span><br><span class="line">        bufr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>（弥补了流操作的不足，流不可以操作文件夹，文件信息）</p>
<p>用来将文件或者文件夹封装成对象</p>
<p>方便对文件与文件夹的属性信息进行操作</p>
<p>File对象可以作为参数传递给流的构造函数。</p>
<pre><code>常用方法：
1. 创建
    boolean createNewFile（）：在指定位置创建文件，如果文件已存在返回false（和输出流不同，输出流对象会覆盖已存在的文件）

    boolean mkdir() 创建文件夹
    boolean mkdirs() 创建多级文件夹
2. 删除
    boolean delete（）删除失败时返回false
3.判断
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归列出目录下所有内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java1223"</span>);</span><br><span class="line">        showDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDir</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">        System.out.println(dir);</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;files.length; x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(files[x].isDirectory())</span><br><span class="line">                showDir(files[x]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(files[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><p>ByteArrayOutputStream类（字节数组输出流）：</p>
<ul>
<li>构造时不用定义数据目的，因为该对象内部封装了可变长度的字节数组。（在内存中创建一个字节数组缓冲区，所有发送到输出流的数据保存其中）</li>
</ul>
<p>ByteArrayIutputStream类：</p>
<ul>
<li>构造时要接收数据源，且数据源是一个字节数组。</li>
</ul>
<p>这两个流对象都操作的数组，并没有使用系统资源，所以不用close。</p>
<pre><code>原设备
    键盘 System.in， 硬盘FileStream，内存 ArrayStream
目的设备
    控制台 System.out,硬盘 FileStream，内存 ArrayStream
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据源</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"ABCD"</span>.getBytes());</span><br><span class="line">        <span class="comment">//数据目的</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> by = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((by=bis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(by);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/排序整理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/15/排序整理/" itemprop="url">排序整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-15T10:07:25+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择"><a href="#简单选择" class="headerlink" title="简单选择"></a>简单选择</h3><blockquote>
<p>一种简单且直观的排序算法。</p>
<p>不断在剩余元素中选择最小者，因此叫选择排序。</p>
</blockquote>
<p><strong>思想：</strong></p>
<ul>
<li>找到数组中最小的元素，和a[0]交换</li>
<li>在剩下的元素里找到最小的元素，和a[1]交换</li>
</ul>
<p>两个鲜明特点；</p>
<ol>
<li>和输入的初始状态无关。 哪怕原数组已排序完成，也是O(n²)</li>
<li>数据移动最少。选择排序用了N次交换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;a[min])</span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h4><p>堆排序是对简单选择排序的改进。</p>
<p>堆是一颗完全二叉树。</p>
<p>有n个节点，堆的索引从0开始，<strong>节点i的</strong></p>
<ul>
<li>左孩子：2⋅i+1</li>
<li>右孩子：2⋅i+2</li>
<li>父亲：（i−1）/2</li>
<li>最后一个父节点：（n/2）-1</li>
</ul>
<p><strong>堆添加</strong></p>
<p>先把元素<strong>添加到末尾</strong>，再<strong>依次向上面调整</strong>，若大于父节点，就<strong>和父节点交换</strong>。</p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap_04.jpg" alt="img"></p>
<p><strong>堆删除</strong></p>
<p><strong>删除堆顶元素</strong>：把末尾元素，放到堆顶，再依次向下调整，每次<strong>选择较大的子节点进行交换</strong>。</p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap_05.jpg" alt="img"></p>
<p><strong>删除堆中元素</strong>：把末尾元素，放入空白处，再调整堆即可。</p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap_06.jpg" alt="img"></p>
<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h4><p><strong>思路</strong></p>
<ol>
<li>初始化堆。把a1,⋯,an构造成为大顶堆</li>
<li>取出最大值（将其与堆数组的末尾元素交换，此时末尾元素就是最大值)。将a1与an交换，再把a1,⋯.an−1调整为最大堆。</li>
<li>重复2 (即，交换，建堆；交换，建堆…)</li>
</ol>
<p><strong>建立堆</strong></p>
<p>n个元素，<strong>最后一个父亲节点</strong>：下标 k=n/2−1。</p>
<p>对这些节点ak,⋯,a0， <strong>依次调整它们的子树，使子树成堆</strong>。即，若<strong>根节点小于左右节点的较大值，则交换</strong>。</p>
<p><strong>举例</strong></p>
<p>对于数据{20,30,90,40,70,110,60,10,100,50,80}，建立为最大堆{110,100,90,40,80,20,60,10,30,50,70}</p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p1_01.jpg" alt="img"></p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p1_02.jpg" alt="img"></p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p1_03.jpg" alt="img"></p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p1_04.jpg" alt="img"></p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p1_05.jpg" alt="img"></p>
<p><strong>取出最大值</strong></p>
<p>把根节点（最大值）和当前堆的末尾值进行交换，最大值放到最后。再对剩余的数据进行成堆，再依次取最大值交换。</p>
<p><img src="http://plm-images.oss-cn-hongkong.aliyuncs.com/image/ds/heap/heap_p2.jpg" alt="img"></p>
<p>每一次取出最大值重新恢复堆，要O(logn)，有n个数，一共是O(nlogn)。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n  = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>-<span class="number">1</span>; i&gt;= <span class="number">0</span>;i-- )&#123;</span><br><span class="line">            maxHeap(a,i,n-<span class="number">1</span>);  <span class="comment">// 初始化一个最大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            exch(a,<span class="number">0</span>,i);</span><br><span class="line">            maxHeap(a,<span class="number">0</span>,i-<span class="number">1</span>); <span class="comment">// 保证a[0...i-1]依然是个最大堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child;</span><br><span class="line">        <span class="keyword">int</span> cur = start;</span><br><span class="line">        <span class="keyword">for</span>(;<span class="number">2</span>*cur+<span class="number">1</span>&lt;=end;cur = child)&#123;</span><br><span class="line">            child = <span class="number">2</span>*cur+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child+<span class="number">1</span>&lt;=end &amp;&amp; a[child+<span class="number">1</span>]&gt;a[child])  <span class="comment">// 先找到较大的孩子；有右孩子，且右孩子比左孩子大，则选择右孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            <span class="keyword">if</span>(a[child] &gt; a[cur])&#123;  <span class="comment">// 孩子大于父亲，则交换</span></span><br><span class="line">                exch(a,child,cur);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结分析</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>最好</th>
<th>最差</th>
<th>空间</th>
<th>稳定</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote>
<p>将元素插入到有序数组里。</p>
<p>将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p>
<p>可以边比较边交换；或者先比较，大的右移，找到位置再插入（采用这种）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt; len;i++)&#123; <span class="comment">//从1开始,假设a[0]有序</span></span><br><span class="line">            <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; a[j-<span class="number">1</span>]&gt;tmp)&#123;</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    a[j] = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote>
<p>简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
<p>希尔排序又称为<code>缩小增量排序</code>， 把整个列表，分成多个[i,i+d,i+2d,…,i+kd]这样的列表，每个进行直接插入排序。每一轮不断缩小d的值，直到全部有序。</p>
</blockquote>
<p>实际例子 <code>4 5 1 2 6 3</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># d = 3</span><br><span class="line"><span class="number">4</span> _ _ <span class="number">2</span> _ _</span><br><span class="line">_ <span class="number">5</span> _ _ <span class="number">6</span> _</span><br><span class="line">_ _ <span class="number">1</span> _ _ <span class="number">3</span></span><br><span class="line"># 化为3个列表，分别进行直接插入排序，得到</span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># d = 2</span><br><span class="line"><span class="number">2</span> _ <span class="number">1</span> _ <span class="number">6</span> _</span><br><span class="line">_ <span class="number">5</span> _ <span class="number">4</span> _ <span class="number">3</span></span><br><span class="line"># 排序，得到</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># d = 1</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"># 直接插入排序，得到</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。</p>
</blockquote>
<p>可通过两种方式实现：</p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ul>
<p>递归实现的步骤：</p>
<p>分解&amp;递归&amp;合并</p>
<ol>
<li>分解 – 将区间一分为二，求分裂点<code>mid = (lo+hi)/2</code></li>
<li>递归求解，sort，终结条件是区间长度为1:  <code>lo&gt;=hi</code> （其实sort的作用是决定调用merge的时机）</li>
<li>合并，merge – 把两个有序的子区间<code>a[lo]...a[mid],a[mid+1]...a[hi]</code>,合并成一个有序区间</li>
</ol>
<p><img src="https://i.loli.net/2019/03/25/5c98f8dd22259.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">    sort(a,low,mid);</span><br><span class="line">    sort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">    <span class="comment">//左右归并</span></span><br><span class="line">    merge(a,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i= low;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;temp.length;x++)&#123;</span><br><span class="line">        a[x+low] = temp[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n) ，merge占用</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>归并排序的形式是一颗二叉树，遍历的次数就是二叉树的深度O(logn)， 而一共n个数。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>冒泡比较的是相邻元素，大的下沉</li>
<li>每趟排序确定一个最下面位置的数</li>
</ol>
<p>冒泡排序算法的运作如下：</p>
<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>③. 针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    public static void bubbleSort(int[] a)&#123;</span><br><span class="line">    if(a == null || a.length == 0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i &lt; a.length;i++)&#123;</span><br><span class="line">        for(int j = 0; j &lt; a.length-1-i; j++)&#123;</span><br><span class="line">            if(a[j] &gt; a[j+1])&#123;</span><br><span class="line">                int tmp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>思路：</p>
<ul>
<li><p>选一个数(第一个)为基准v；</p>
</li>
<li><p>进行划分（partition）。左边小于等于x，中间x，右边大于等于x；</p>
</li>
<li><p>再递归地划分左右两边。</p>
</li>
</ul>
<p>（设置两个指针lo和hi，它们分别指向待排序的数组的头尾；每一趟是把基准归位）</p>
<p><strong>递归快排</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(lo&gt;=hi || a == <span class="keyword">null</span> || a.length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> v = partition(a,lo,hi);</span><br><span class="line">      quickSort(a,lo,v-<span class="number">1</span>);</span><br><span class="line">      quickSort(a,v+<span class="number">1</span>,hi);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> v = a[lo];</span><br><span class="line">      <span class="keyword">while</span> (lo&lt;hi)&#123;</span><br><span class="line">          <span class="keyword">while</span> (lo&lt;hi &amp;&amp; a[hi]&gt;=v)&#123; <span class="comment">//当&gt;=时，先从后往前(移动指针时保证lo&lt;hi)</span></span><br><span class="line">              hi--;</span><br><span class="line">          &#125;</span><br><span class="line">          exch(a,lo,hi);            </span><br><span class="line">          <span class="keyword">while</span> (lo&lt;hi &amp;&amp; a[lo]&lt;=v)&#123;</span><br><span class="line">              lo++;</span><br><span class="line">          &#125;</span><br><span class="line">          exch(a,lo,hi);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> lo; <span class="comment">//返回轴</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">      a[i] = a[j];</span><br><span class="line">      a[j] = tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归快排</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 用栈模拟，存放lo和hi</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        stack.push(end);  <span class="comment">//较大的下标先入栈</span></span><br><span class="line">        stack.push(start);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> hi = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> index = partition(a, lo, hi);</span><br><span class="line">            <span class="keyword">if</span> (lo &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(lo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hi &gt; index + <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(hi);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>最好</th>
<th>最差</th>
<th>空间</th>
<th>稳定</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>快排</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O($n^2$)</td>
<td>O(logn)栈的深度</td>
<td>不稳定</td>
<td>基本有序或者逆序，效果最差</td>
</tr>
</tbody>
</table>
<p>快排最好的情况是，每次正好中分，复杂度为O(nlogn)</p>
<p>最差情况，每一趟数都划分到基准的一边，另一边为空，复杂度为O(n^2)；如果用树画出来，得到的将会是一棵单斜树，需要执行n‐1次递归调用（n-1+n-2+…+1=n(n-1)/2）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>思想总结</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>一句话描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入</td>
<td>前面有序，为新来的，在前面找到合适的位置，进行插入</td>
</tr>
<tr>
<td>折半插入</td>
<td>前面有序，为新来的，使用<strong>折半查找</strong>到插入位置，进行插入</td>
</tr>
<tr>
<td>希尔排序</td>
<td><strong>gap个间隔为gap的子序列</strong>，<strong>每个进行直接插入排序</strong>；减小gap，依次排序，直至为1</td>
</tr>
<tr>
<td>冒泡排序</td>
<td><strong>交换n-1趟</strong>，ai−1&gt;ai，则进行交换，每一趟都有个最大的沉到末尾</td>
</tr>
<tr>
<td>快排</td>
<td>第一个数x，先<strong>划分</strong>，左边小于x，中间x，右边大于x。再依次<strong>递归排序左右两边</strong></td>
</tr>
<tr>
<td>简单选择</td>
<td>前面有序，从后面选择最小的与前面末尾进行交换</td>
</tr>
<tr>
<td>堆排序</td>
<td>初始化<strong>大根堆</strong>，<strong>堆顶和末尾元素交换</strong>，再调整<strong>使剩下的元素成堆</strong>， 重复</td>
</tr>
<tr>
<td>归并排序</td>
<td><strong>分解</strong>为左右两个序列，对左右两个序列进行<strong>递归归并排序</strong>，<strong>再合并</strong>。即sort,sort,merge</td>
</tr>
<tr>
<td>基数排序</td>
<td>位数一样，从低位到高位，分别按照每一位进行排序</td>
</tr>
</tbody>
</table>
<p><strong>时空复杂度总结</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>最好</th>
<th>最差</th>
<th>空间</th>
<th>稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直插</td>
<td>O($n^2$)</td>
<td>O(n)</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>是</td>
</tr>
<tr>
<td>希尔</td>
<td></td>
<td></td>
<td></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡</td>
<td>O($n^2$)</td>
<td>O(n)</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>是</td>
</tr>
<tr>
<td>快排</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O($n^2$)</td>
<td>O(logn)，栈的深度</td>
<td>不稳定</td>
</tr>
<tr>
<td>简选</td>
<td>O($n^2$)</td>
<td>O($n^2$)</td>
<td>O($n^2$)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog⁡n)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog⁡n)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)， merge占用</td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(r)， r个队列</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>稳定的：<strong>插、冒、归、基</strong></p>
<p>比较次数与初始状态无关：<strong>选择O($n^2$)、</strong>归并**O(nlogn)</p>
<p>排序趟数与初始状态无关：选择、插入、基数</p>
<p>冒、选、堆：每趟都有1个在最终的位置</p>
<p><strong>时间复杂度</strong>：<strong>比较重要的三种：快归堆，都是</strong>O(nlogn)，基数排序O(d(n+r))， 其余O($n^2 $)，</p>
<p><strong>空间复杂度</strong>：归O(n)， 快O(logn)， 基O(r)， 其余O(1)</p>
<p><strong>算法选择</strong></p>
<table>
<thead>
<tr>
<th>条件</th>
<th>可选算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>n较小， n≤50n≤50</td>
<td>直接插入、简单选择</td>
</tr>
<tr>
<td>基本有序</td>
<td>直接插入、冒泡</td>
</tr>
<tr>
<td>n较大，要O(nlogn)O(nlog⁡n)</td>
<td>快排、堆排（不稳定），归并排序（稳定）</td>
</tr>
<tr>
<td>n较大，要快，要稳定</td>
<td>归并排序，与直插结合的改进的归并排序</td>
</tr>
<tr>
<td>n很大，位数很少，可以分解</td>
<td>基数排序</td>
</tr>
<tr>
<td>记录本身信息量太大</td>
<td>为了避免移动，可以使用链表作为存储结构</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/mybatis学习整理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/mybatis学习整理/" itemprop="url">mybatis学习整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T15:51:09+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>持久层框架。MyBatis使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs 映射成数据库中的记录。</p>
<h2 id="配置及增删改查"><a href="#配置及增删改查" class="headerlink" title="配置及增删改查"></a>配置及增删改查</h2><ul>
<li>pojo：不按mvc分层，只是java bean有一些属性，get和set方法</li>
<li>domain：不按mvc分层，只是java bean有一些属性，get和set方法</li>
<li>po：[persistant object]持久层对象。最形象的理解就是一个PO就是数据库中的一条记录。<br>好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。<br>它里面的java bean类名=表名，属性名=表的字段名，还有对应的get set方法</li>
<li>vo：[Value Object] 值对象，[ViewObject]表现层对象。主要用于在高级查询中从页面传过来的各种参数，好处是扩展性强</li>
<li>bo：用在service层，现在基本不用</li>
</ul>
<p>映射文件 UserMapper.xml</p>
<p>UserMapper.java（接口）</p>
<p>接口和映射文件在同一目录下<br>mapper接口代理规则：</p>
<ol>
<li>映射文件中namespace等于接口的全路径名</li>
<li>映射文件中sql的id等于<strong>接口中方法名</strong></li>
<li>映射文件中传入参数类型和返回结果集类型等于接口方法里的传入和返回类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--namespace:命名空间，做spl隔离&gt;</span><br><span class="line">&lt;mapper namespace=&quot; &quot;&gt;</span><br><span class="line">&lt;!--parameterType:指定传入参数类型</span><br><span class="line">resultType：返回结果集类型</span><br><span class="line">#&#123;&#125;占位符：如果传入基本类型，&#123;&#125;内容可以随意写&gt;</span><br><span class="line">&lt;select id=&quot;findUserById&quot;  parameterType=&quot;java.lang.Integer&quot; resultType=&quot;cn.pojo.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查询</span><br><span class="line">&lt;!--$&#123;&#125;拼接符，如果传入基本类型，变量必须是value，用like是时会用&gt;</span><br><span class="line">&lt;select id=&quot;findUserById&quot;  parameterType=&quot;java.lang.Integer&quot; resultType=&quot;cn.pojo.User&quot;&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    where username like &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//增加</span><br><span class="line">&lt;!--如果传入pojo类型，那么#&#123;&#125;变量名必须是pojo中对应的属性&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.pojo.User&quot; &gt;</span><br><span class="line">    insert into user (username,sex)</span><br><span class="line">    values (#&#123;username&#125;,#&#123;sex&#125;) </span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">&lt;delete id=&quot;delUserById&quot; parameterType=&quot;cn.pojo.User&quot; &gt;</span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  </span><br><span class="line">//更新</span><br><span class="line">&lt;update id=&quot;delUserById&quot; parameterType=&quot;cn.pojo.User&quot; &gt;</span><br><span class="line">    update user set username=#&#123;username&#125; whrere id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>
<p>核心配置文件SqlMapconfig，<br>其中重要的有</p>
<ul>
<li>properties（jdbc 用户名 密码等）</li>
<li><p>typeAliases 类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases type=&quot;&quot; alias=&quot;&quot;/&gt;</span><br><span class="line">或者使用包扫描</span><br><span class="line">&lt;package name=&quot;包&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper<br>使用包扫描批量引入mapper接口</p>
</li>
</ul>
<h2 id="输入映射和输出映射"><a href="#输入映射和输出映射" class="headerlink" title="输入映射和输出映射"></a>输入映射和输出映射</h2><p>使用resultType进行输出映射，只有查询出来的++列名和实体类中的属性名++一致，该列才可以映射成功。</p>
<p>返回：对象或者基本类型（只有返回结果是一行一列时）</p>
<p>不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。</p>
<h2 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h2><ul>
<li>if</li>
</ul>
<p>动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogWithTitleLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE state = ‘ACTIVE’ </span><br><span class="line">  &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>where</li>
</ul>
<p>where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，<strong>若语句的开头为“AND”或“OR”，where 元素也会将它们去除</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  &lt;where&gt; </span><br><span class="line">    &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt; </span><br><span class="line">    &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach</li>
</ul>
<p>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 ++IN 条件语句++的时候。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//item:每次循环出的数据放到这个变量里，collection：传入集合的变量名</span><br><span class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=&quot;id&quot;  collection=&quot;ids&quot;</span><br><span class="line">      open=&quot;id in (&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及在迭代结果之间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p>
<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>由订单查用户(order为主),一个订单对应一个用户</p>
<blockquote>
<p>手动映射</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">id：ResultMap的唯一标识</span><br><span class="line">type：将查询出的数据放入这里的指定对象中</span><br><span class="line">注意：手动映射需要指定表的字段名column和类的属性名property的对应关系</span><br><span class="line">*/</span><br><span class="line">&lt;resultMap type=&quot;&quot; id=&quot;oderResultMap&quot;&gt;</span><br><span class="line">    //id标签指定主键字段的对应关系</span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">    //result标签指定非主键字段的对应关系</span><br><span class="line">    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    //上面是order表里的，接下来写user里的</span><br><span class="line">    //association:指定单个对象的对应关系(order对象里有一个user对象)</span><br><span class="line">    //property：指定将数据放入Order里的user属性中</span><br><span class="line">    //javaType：user属性的类型</span><br><span class="line">    &lt;association property=&quot;user&quot; javaType=&quot;cn.ithema.pojo.User&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findOrdersAndUser1&quot; resultMap=&quot;oderResultMap&quot;&gt;</span><br><span class="line">  SELECT a.*,b.id uid,username,sex</span><br><span class="line">  FROM orders a,user b</span><br><span class="line">  WHERE a.user_id = b.id</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>从用户看订单，一个用户对应多个订单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;cn.ithema.pojo.User&quot; id=&quot;userResultMap&quot;&gt;</span><br><span class="line">    //id标签指定主键字段的对应关系</span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    //上面是user表里的，接下来写order里的</span><br><span class="line">    //collection:指定集合对象关系映射(user对象里有List&lt;Orders&gt;)</span><br><span class="line">    //property：将数据放入User对象里的orderlist属性中</span><br><span class="line">    //ofType：指定orderlist属性的泛型类型</span><br><span class="line">    &lt;collection property=&quot;orderlist&quot; ofType=&quot;cn.ithema.pojo.Orders&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;oid&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;findUserAndOrders&quot; resultMap=&quot;userResultMap&quot;&gt;</span><br><span class="line">  SELECT a.*,b.id oid,user_id,number,createtime</span><br><span class="line">  FROM user a，orders b</span><br><span class="line">  WHERE a.id=b.user_id </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="for面试"><a href="#for面试" class="headerlink" title="for面试"></a>for面试</h2><p>与spring整合后，会话工厂归spring管理</p>
<p>&lt;bean id=”splSessionFactory”,class=…</p>
<blockquote>
<p>占位符#{}和${}的区别是什么？</p>
</blockquote>
<p>在Mybatis中，有两种占位符</p>
<p> #{}解析传递进来的参数数据</p>
<p> ${}对传递进来的参数原样拼接在SQL中</p>
<p> #{}是预编译处理，${}是字符串替换。</p>
<p> 使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<blockquote>
<p>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</p>
</blockquote>
<p>Dao接口，就是人们常说的Mapper接口，<br>接口的全限名，就是映射文件中的namespace的值，</p>
<p>接口的方法名，就是映射文件中MappedStatement的id值，</p>
<p>接口方法内的参数，就是传递给sql的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。</p>
<p>Dao接口里的方法，是++不能重载的++，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK++动态代理++，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，++代理对象proxy会拦截接口方法++，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<blockquote>
<p>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</p>
</blockquote>
<p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。</resultmap></p>
<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis++通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回++，那些找不到映射关系的属性，是无法完成赋值的。</p>
<blockquote>
<p>在mapper中如何传递多个参数?</p>
</blockquote>
<p>使用 @param 注解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.ibatis.annotations.param; </span><br><span class="line">    public interface usermapper &#123; </span><br><span class="line">     user selectuser(@param(“username”) string username, </span><br><span class="line">     @param(“hashedpassword”) string hashedpassword); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper): </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=”selectuser” resulttype=”user”&gt; </span><br><span class="line">     select id, username, hashedpassword </span><br><span class="line">     from some_table </span><br><span class="line">     where username = #&#123;username&#125; </span><br><span class="line">     and hashedpassword = #&#123;hashedpassword&#125; </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</p>
</blockquote>
<p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<blockquote>
<p>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</p>
</blockquote>
<p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<blockquote>
<p>批量操作</p>
</blockquote>
<p>主要使用<foreach></foreach></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; index=&quot;index&quot;&gt;</span><br><span class="line">   #&#123;item.xx&#125;, #&#123;item.xx&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">collection=&quot;list&quot;    其中list是固定的，如果是数组就是array</span><br><span class="line">item=&quot;item&quot;         循环中每一项的别名</span><br><span class="line">open=&quot;&quot;             开始标识，比如删除in (id1,id2)， open=&quot;(&quot; close=&quot;)&quot;</span><br><span class="line">close=&quot;&quot;            结束标识</span><br><span class="line">separator=&quot;,&quot;       分隔符号</span><br><span class="line">index=&quot;index&quot;       下标值</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 批量保存用户,并返回每个用户插入的ID --&gt;</span><br><span class="line">&lt;insert id=&quot;batchSave&quot; parameterType=&quot;java.util.List&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">    INSERT INTO `test`.`tb_user`(`username`, age)</span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        (#&#123;item.username&#125;, #&#123;item.age&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 批量删除用户 --&gt;</span><br><span class="line">&lt;delete id=&quot;batchDelete&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">    DELETE FROM `test`.`tb_user` WHERE id IN</span><br><span class="line">    &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
<p>resultType和resultMap功能类似  ，都是返回对象信息  ，但是resultMap要更强大一些 ，可自定义。因为resultMap要配置一下，表和类的一一对应关系，所以说就算你的字段名和你的实体类的属性名不一样也没关系，都会给你映射出来，但是，resultType就比较鸡肋了，必须字段名一样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/理解JVM/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/理解JVM/" itemprop="url">理解JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T15:13:12+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： </p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，记录<strong>正在执行的虚拟机字节码指令的地址</strong>（如果正在执行的是本地方法则为空）。</p>
<p>Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有的，与线程生命周期相同。</p>
<p>Java虚拟机栈是描述<code>Java方法运行过程</code>的内存模型。 </p>
<p>Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：</p>
<ul>
<li>局部变量表 </li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息<br>等</li>
</ul>
<p>当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。<br>当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。</p>
<p>注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。<br>这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>跟虚拟机栈很像，不过它是为虚拟机使用到的本地方法服务。</p>
<p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代（Young Generation）</li>
<li>老年代（Old Generation）</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 </p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。<strong>为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</strong></p>
<p>（运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<p>）</p>
<ul>
<li>Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。<br>两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。<br>只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。</li>
<li>Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。</li>
<li>堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</li>
<li><strong>程序计数器、Java虚拟机栈、本地方法栈</strong>（计数器和两个栈）是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。<br>而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法区。并在JVM启动的时候就创建，JVM停止才销毁。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。</p>
<p>垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h3 id="如何判定哪些对象需要回收（判断一个对象是否存活）？"><a href="#如何判定哪些对象需要回收（判断一个对象是否存活）？" class="headerlink" title="如何判定哪些对象需要回收（判断一个对象是否存活）？"></a>如何判定哪些对象需要回收（判断一个对象是否存活）？</h3><p>在对堆进行对象回收之前，首先要判断哪些是无效对象。我们知道，一个对象不被任何对象或变量引用，那么就是无效对象，需要被回收。一般有两种判别方式：</p>
<ol>
<li><p>引用计数法 </p>
<pre><code>每个对象都有一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
</code></pre></li>
</ol>
<ol start="2">
<li><p>可达性分析法 </p>
<pre><code>所有和GC Roots直接或间接关联的对象都是有效对象，和GC Roots没有关联的对象就是无效对象。 
</code></pre></li>
</ol>
<p>GC Roots是指：</p>
<ul>
<li>Java虚拟机栈所引用的对象(栈帧中局部变量表中引用类型的变量所引用的对象)</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈所引用的对象 </li>
</ul>
<p>PS：注意！GC Roots并不包括堆中对象所引用的对象！这样就不会出现循环引用。</p>
<p>两者对比：<br>引用计数法虽然简单，但存在一个严重的问题，它无法解决循环引用的问题。<br>因此，目前主流语言均使用可达性分析方法来判断对象是否有效。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>finalize()，类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就<code>有可能在该方法中让对象重新被引用</code>，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p>
<hr>
<p>当JVM筛选出失效的对象之后，并不是立即清除，而是再给对象一次重生的机会，具体过程如下：</p>
<p>判断该对象是否覆盖了finalize()方法</p>
<p>若已覆盖该方法，并未被执行过，那么就会将finalize()扔到F-Queue队列中；</p>
<p>若未覆盖该方法，则直接释放对象内存。</p>
<p>执行F-Queue队列中的finalize()方法。<br>虚拟机会以较低的优先级执行这些finalize()方法们，也不会确保所有的finalize()方法都会执行结束。如果finalize()方法中出现耗时操作，虚拟机就直接停止执行，将该对象清除。</p>
<p>如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<ol>
<li>强引用</li>
</ol>
<p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>软引用</li>
</ol>
<p>被软引用关联的对象只有在<strong>内存不够</strong>的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;  // 使对象只被软引用关联</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>弱引用</li>
</ol>
<p>被弱引用关联的对象<strong>一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>虚引用</li>
</ol>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能<strong>在这个对象被回收时收到一个系统通知</strong>。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure>
<h3 id="垃圾收集的方法有哪些"><a href="#垃圾收集的方法有哪些" class="headerlink" title="垃圾收集的方法有哪些"></a>垃圾收集的方法有哪些</h3><p>1、标记-清除</p>
<p>标记要回收的对象，然后清除。</p>
<p>不足：</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li>
</ul>
<p>2、标记-整理</p>
<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>优点:</p>
<p>不会产生内存碎片</p>
<p>不足:</p>
<p>需要移动大量对象，处理效率比较低。</p>
<p>3、复制算法</p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<p>4、分代收集</p>
<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类从加载进内存到卸载出内存为止，一共经历7个阶段： </p>
<p>加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;<em>使用——&gt;卸载</em></p>
<p>其中，类加载包括5个阶段：<br>加载——&gt;[验证——&gt;准备——&gt;解析]——&gt;初始化</p>
<p>在类加载的过程中，以下3个过程称为连接：<br>验证——&gt;准备——&gt;解析</p>
<p>因此，JVM的类加载过程也可以概括为3个过程：<br>加载——&gt;连接——&gt;初始化</p>
<p>我们已经知道，类加载的过程包括：加载、连接、初始化，连接又分为：验证、准备、解析，所以说类加载一共分为5步：++加载、验证、准备、解析、初始化++。</p>
<p>其中加载、验证、准备、初始化的开始顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。<br>而解析过程会发生在初始化过程中。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>注意：“加载”是“类加载”过程的第一步，千万不要混淆。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载过程中，JVM主要做3件事情：</p>
<ol>
<li><p>通过类的完全限定名称获取定义该类的二进制字节流,即class文件</p>
<p> 在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。</p>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li><p>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</p>
<p> 接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。</p>
</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段比较耗时，它非常重要但不一定必要，如果所运行的代码已经被反复使用和验证过，那么可以使用-Xverify:none参数关闭，以缩短类加载时间。</p>
<ul>
<li>验证的目的是什么？</li>
</ul>
<p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<ul>
<li>验证的过程</li>
</ul>
<ol>
<li><p>文件格式验证 </p>
<p> 这个阶段主要验证输入的二进制字节流是否符合class文件结构的规范。<br> 二进制字节流只有通过了本阶段的验证，才会被允许存入到方法区中。 </p>
<p> 本验证阶段是基于二进制字节流的，而后面的三个验证阶段都是在方法区中进行，并基于类特定的数据结构的。 </p>
<p> 通过上文可知，加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区。而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区。也就是说，++加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中++，继而开始下阶段的验证和创建Class对象等操作。</p>
<pre><code>这个过程印证了：加载和验证是交叉进行的。
</code></pre></li>
<li><p>元数据验证 </p>
<p> 本阶段对方法区中的++字节码描述信息++进行语义分析，确保其符合Java语法规范。</p>
</li>
<li><p>字节码验证 </p>
<p> 本阶段是验证过程的最复杂的一个阶段。<br>本阶段对++方法体++进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</p>
</li>
<li><p>符号引用验证 </p>
<p> 本阶段验证发生在++解析阶段++，确保解析能正常执行。 </p>
</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>类变量是被 static 修饰的变量，<code>准备阶段为类变量分配内存并设置初始值</code>，存储在方法区中。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0,null,false，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 123;</span><br></pre></td></tr></table></figure>
<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value = 123;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。 </p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。</p>
<p>初始化阶段就是执行类构造器clinit()的过程。 </p>
<p>clinit()方法由编译器自动产生，收集类中所有<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生。在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。</p>
<p>初始化过程的注意点</p>
<ul>
<li>如果一个类/接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会生成clinit()方法。</li>
<li>clinit()方法中静态成员变量的赋值顺序是根据Java代码中成员变量的出现的顺序决定的。</li>
<li>因为虚拟机会确保父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。</clinit></li>
<li>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。</clinit></clinit></clinit></li>
<li>虚拟机会加锁保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，因此当多条线程同时执行某一个类的clinit()方法时，只有一个方法会被执行，其它的方法都被阻塞。并且，只要有一个clinit()方法执行完，其它的clinit()方法就不会再被执行。因此，在同一个类加载器下，同一个类只会被初始化一次。</clinit></li>
</ul>
<h3 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h3><h4 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h4><ol>
<li><p>在运行过程中遇到如下字节码指令时，如果类尚未初始化，那就要进行初始化：new、getstatic、putstatic、invokestatic。这四个指令对应的Java代码场景是： </p>
<pre><code>通过new创建对象；
读取、设置一个类的静态成员变量(不包括final修饰的静态变量)；
调用一个类的静态成员函数。
</code></pre></li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，那就需要初始化；</li>
<li>当初始化一个类的时候，若其父类尚未初始化，那就先要让其父类初始化，然后再初始化本类；</li>
<li>当虚拟机启动时，虚拟机会首先初始化带有main方法的类，即主类； </li>
</ol>
<p>接口的初始化：</p>
<p>接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，只有程序在运行过程中用到当父接口中的东西时才初始化父接口。</p>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>以上 4 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义</span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = new SuperClass[10];</span><br></pre></td></tr></table></figure>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器的作用：</p>
<p>将class文件加载进JVM的方法区，并在方法区中创建一个java.lang.Class对象作为外界访问这个类的接口。</p>
<p>类与类加载器的关系：</p>
<p>比较两个类是否相等，只有当这两个类由同一个加载器加载才有意义；否则，即使同一个class文件被不同的类加载器加载，那这两个类必定不同，即通过类的Class对象的equals执行的结果必为false。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/数据库学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/28/数据库学习/" itemprop="url">数据库学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T15:04:47+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文整理数据库相关的知识点（更新中）</p>
<hr>
<p>  关系型数据库：存放实体与实体之间的关系的数据库</p>
<p>  非关系型数据库：存放的是对象（redis） no-sql</p>
<p>  常见的关系型数据库：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql         oracle   开源数据库</span><br><span class="line">oracle        oracle   大型收费的数据库</span><br><span class="line">DB2           IBM      大型收费的数据库</span><br><span class="line">sqlserver     微软     中大型收费数据库</span><br></pre></td></tr></table></figure>
<h3 id="sql的分类："><a href="#sql的分类：" class="headerlink" title="sql的分类："></a>sql的分类：</h3><ul>
<li><p>DDL:数据定义语言</p>
<ul>
<li>操作对象：数据库和表</li>
<li>关键词：create alter drop</li>
<li>操作数据库：<ul>
<li>create database 数据库名称；</li>
<li>drop database 数据库名称；</li>
<li>查看所有数据库：show databases；</li>
</ul>
</li>
<li><p>操作表：</p>
<ul>
<li><p>创建表：</p>
<p>create table 表名（字段描述，字段描述）；</p>
<p>字段描述：字段名 字段类型 [约束]</p>
</li>
<li>修改表：alter table 表名 …<ul>
<li>修改表名：alter table 旧表名 rename to 新表名；</li>
<li>添加字段：alter table 表名 add 字段描述；</li>
<li>修改字段名：alert table 表名 change 字段名称 新字段描述</li>
<li>修改字段描述：alert table 表名 字段描述；</li>
<li>删除字段：alert table 表名 drop 字段名；</li>
</ul>
</li>
<li>删除表：drop table 表名；</li>
</ul>
</li>
<li>常用命令：<ul>
<li>切换或者进入数据库：use 数据库名称；</li>
<li>查看当前数据库的所有表：show tables；</li>
<li>查看表结构：desc 表名；</li>
<li>查看建表语句：show create table 表名；</li>
</ul>
</li>
</ul>
</li>
<li><p>DML:数据操作语言</p>
<ul>
<li>操作对象：记录（行）</li>
<li>关键词：insert update delete</li>
<li>插入<ul>
<li>insert into 表名 values（字段值1，…，字段值n）；默认插入全部字段</li>
<li>insert into 表名（字段名，字段名…）values（字段值，字段值1…）</li>
</ul>
</li>
<li>修改<ul>
<li>update 表名 set 字段名=字段值，…[where 条件]；</li>
</ul>
</li>
<li>删除<ul>
<li>delete from 表名 [where 条件]；</li>
</ul>
</li>
</ul>
</li>
<li><p>DQL：数据查询语言（非官方叫法）</p>
<ul>
<li>关键词：select</li>
<li>格式：select … from 表名 where 条件 group by 分组字段 order by 排序字段 ase|desc</li>
</ul>
</li>
<li>DCL：数据控制语言<ul>
<li>操作对象：用户，事务，权限</li>
</ul>
</li>
</ul>
<p>聚合函数：</p>
<p>sum(),avg(),max(),min(),count()</p>
<h3 id="关系数据库管理系统的特点："><a href="#关系数据库管理系统的特点：" class="headerlink" title="关系数据库管理系统的特点："></a>关系数据库管理系统的特点：</h3><ol>
<li>数据以表格的形式出现</li>
<li>每行为各种<strong>记录名称</strong></li>
<li>每列为记录名称所对应的数据域</li>
<li>许多的行和列组成一张<strong>表单</strong></li>
<li>若干的表单组成database</li>
</ol>
<h3 id="主键和外键："><a href="#主键和外键：" class="headerlink" title="主键和外键："></a>主键和外键：</h3><p>定义主键和外键主要是为了维护关系数据库的完整性，总结一下：</p>
<ol>
<li>主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。</li>
</ol>
<p>身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 </p>
<ol start="2">
<li>外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。</li>
</ol>
<p>比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
<h2 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>概念：事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<blockquote>
<p>ACID</p>
</blockquote>
<ol>
<li><p>原子性（Atomicity）</p>
<p> 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p> 回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
</li>
<li><p>一致性（Consistency）</p>
<p> 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<p> 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。</p>
</li>
<li><p>隔离性（Isolation）</p>
<p> 一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
</li>
<li><p>持久性（Durability）</p>
<p> 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
<p> 使用重做日志来保证持久性。</p>
</li>
</ol>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<ul>
<li>丢失修改</li>
</ul>
<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<ul>
<li>脏读</li>
</ul>
<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<div align="center"><br><img src="https://i.loli.net/2019/03/21/5c934bd109b34.png" width="320" hegiht="313"><br></div>

<ul>
<li>不可重复读*</li>
</ul>
<p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"><br><img src="https://i.loli.net/2019/03/21/5c934bcce83ed.png" width="320" hegiht="313"><br></div>

<ul>
<li>幻读*</li>
</ul>
<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br>（幻读是不可重复读的一种特殊场景）</p>
<div align="center"><br><img src="https://i.loli.net/2019/03/21/5c934bcfb134d.png" width="320" hegiht="313"><br></div>

<p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol>
<li><p>未提交读（READ UNCOMMITTED）</p>
<p> 事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<p> 所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
</li>
<li><p>提交读（READ COMMITTED）</p>
<p> 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<p> 这是<strong>Oracle数据库以及大多数数据库的默认隔离级别</strong>。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。</p>
<p> 这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
</li>
<li><p>可重复读（REPEATABLE READ）</p>
<p> 保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<p> <strong>MySQL的默认事务隔离级别</strong>，innodb在可重复读的隔离级别下，使用next-key-lock锁的算法避免幻读产生，即达到了SERIALIZABLE隔离级别。</p>
<p> 不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
</li>
<li><p>可串行化（SERIALIZABLE）</p>
<p> 强制事务串行执行。<strong>SQL和SQL2的隔离级别</strong></p>
</li>
</ol>
<p>事务的隔离级别越高，并发能力也就越低</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读 </th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>提交读</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>可重复读</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>可串行化</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody>
</table>
<h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是<strong>可重复读</strong>（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引的实现通常使用B树及其变种B+树，是一种数据结构「平衡树」(非二叉)。</p>
<blockquote>
<p>索引的不利：</p>
</blockquote>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>增加了数据库的存储空间（每次给字段建一个新索引，字段中的数据就会被复制一份出来，用于生成索引）</li>
<li>当对表中的数据进行增，删，改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<blockquote>
<p>创建索引</p>
</blockquote>
<ol>
<li><p>表的主键、外键必须有索引；</p>
</li>
<li><p>数据量超过300的表应该有索引；</p>
</li>
<li><p>经常与其他表进行连接的表，在连接字段上应该建立索引；</p>
</li>
<li><p>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</p>
</li>
<li><p>索引应该建在选择性高的字段上；</p>
</li>
<li><p>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</p>
</li>
<li><p>频繁进行数据操作的表，不要建立太多的索引；</p>
</li>
</ol>
<blockquote>
<p>索引种类</p>
</blockquote>
<p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>
<ol>
<li><p>唯一索引 </p>
<p> 索引列的值必须唯一，但允许有空值。</p>
<p> 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</p>
</li>
<li><p>主键索引</p>
<p> 数据库表经常有<strong>一列或列组合</strong>，其值唯一标识表中的每一行。该列称为表的主键。</p>
<p> 数据库为主键自动创建主键索引，<strong>主键索引是唯一索引的特定类型</strong>。</p>
<pre><code>主键不一定只包含一个字段，所以如果你在主键的其中一个字段建唯一索引还是必要的；
主键与唯一索引不同的是：
(1).主健不可为空
(2).每个表只能有一个
</code></pre></li>
<li><p>聚集索引</p>
<p> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。<br>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
