<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,">










<meta name="description" content="JVM内存模型Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是：  程序计数器程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。 Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，++为了线程切换后能恢复到正确的位置++，每条线程都需要一个独立的程序计数器，互不影响，该区域为“++线程私有++”。 注">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="理解JVM">
<meta property="og:url" content="http://yoursite.com/2018/12/28/理解JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JVM内存模型Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是：  程序计数器程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。 Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，++为了线程切换后能恢复到正确的位置++，每条线程都需要一个独立的程序计数器，互不影响，该区域为“++线程私有++”。 注">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-16T11:43:37.104Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解JVM">
<meta name="twitter:description" content="JVM内存模型Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是：  程序计数器程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。 Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，++为了线程切换后能恢复到正确的位置++，每条线程都需要一个独立的程序计数器，互不影响，该区域为“++线程私有++”。 注">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/28/理解JVM/">





  <title>理解JVM | Hexo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/28/理解JVM/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">理解JVM</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-28T15:13:12+08:00">
                2018-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： </p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。</p>
<p>Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，++为了线程切换后能恢复到正确的位置++，每条线程都需要一个独立的程序计数器，互不影响，该区域为“++线程私有++”。</p>
<p>注：但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。 </p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有的，与线程生命周期相同。</p>
<p>Java虚拟机栈是描述++Java方法运行过程++的内存模型。 </p>
<p>Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括：</p>
<ul>
<li>局部变量表 </li>
<li>存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息<br>等</li>
</ul>
<p>当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。<br>当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。</p>
<p>注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。<br>这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>跟虚拟机栈很像，不过它是为虚拟机使用到的本地方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>堆是用来存放对象的内存空间。<br>几乎所有的对象都存储在堆中。 </p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>Java虚拟机规范中定义方法区是堆的一个逻辑部分。<br>方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 </p>
<ul>
<li>Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。<br>两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。<br>只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。</li>
<li>Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。</li>
<li>堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</li>
<li>++程序计数器、Java虚拟机栈、本地方法栈++（计数器和两个栈）是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。<br>而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法区。并在JVM启动的时候就创建，JVM停止才销毁。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>为了避免Java虚拟机在运行期间内存存满的情况，就必须得有一个垃圾收集者的角色，不定期地回收一些无效内存，以保障Java虚拟机能够健康地持续运行。</p>
<h3 id="如何判定哪些对象需要回收（判断一个对象是否存活）？"><a href="#如何判定哪些对象需要回收（判断一个对象是否存活）？" class="headerlink" title="如何判定哪些对象需要回收（判断一个对象是否存活）？"></a>如何判定哪些对象需要回收（判断一个对象是否存活）？</h3><p>在对堆进行对象回收之前，首先要判断哪些是无效对象。我们知道，一个对象不被任何对象或变量引用，那么就是无效对象，需要被回收。一般有两种判别方式：</p>
<ol>
<li><p>引用计数法 </p>
<pre><code>每个对象都有一个计数器，当这个对象被一个变量或另一个对象引用一次，该计数器加一；若该引用失效则计数器减一。当计数器为0时，就认为该对象是无效对象。
</code></pre></li>
<li><p>可达性分析法 </p>
<pre><code>所有和GC Roots直接或间接关联的对象都是有效对象，和GC Roots没有关联的对象就是无效对象。 
</code></pre></li>
</ol>
<p>GC Roots是指：</p>
<p>Java虚拟机栈所引用的对象(栈帧中局部变量表中引用类型的变量所引用的对象)<br>方法区中静态属性引用的对象<br>方法区中常量所引用的对象<br>本地方法栈所引用的对象 </p>
<p>PS：注意！GC Roots并不包括堆中对象所引用的对象！这样就不会出现循环引用。<br>两者对比：<br>引用计数法虽然简单，但存在一个严重的问题，它无法解决循环引用的问题。<br>因此，目前主流语言均使用可达性分析方法来判断对象是否有效。</p>
<h3 id="回收无效对象的过程"><a href="#回收无效对象的过程" class="headerlink" title="回收无效对象的过程"></a>回收无效对象的过程</h3><p>当JVM筛选出失效的对象之后，并不是立即清除，而是再给对象一次重生的机会，具体过程如下：</p>
<p>判断该对象是否覆盖了finalize()方法</p>
<p>若已覆盖该方法，并该对象的finalize()方法还没有被执行过，那么就会将finalize()扔到F-Queue队列中；</p>
<p>若未覆盖该方法，则直接释放对象内存。</p>
<p>执行F-Queue队列中的finalize()方法。<br>虚拟机会以较低的优先级执行这些finalize()方法们，也不会确保所有的finalize()方法都会执行结束。如果finalize()方法中出现耗时操作，虚拟机就直接停止执行，将该对象清除。</p>
<p>对象重生或死亡<br>如果在执行finalize()方法时，将this赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。</p>
<p>注意：<br>强烈不建议使用finalize()函数进行任何操作！如果需要释放资源，请使用try-finally。<br>因为finalize()不确定性大，开销大，无法保证顺利执行。</p>
<h3 id="垃圾收集的方法有哪些"><a href="#垃圾收集的方法有哪些" class="headerlink" title="垃圾收集的方法有哪些"></a>垃圾收集的方法有哪些</h3><p>1、标记-清除</p>
<p>这是垃圾收集算法中最基础的，它的思想就是标记哪些要被回收的对象，然后统一回收。</p>
<p>这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</p>
<p>2、复制算法</p>
<p>为了解决效率问题，复制算法将可用内存按容量划分为++相等的两部分++，然后每次只使用其中的一块，当一块内存用完时，就将++还存活的对象++复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。</p>
<p>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)</p>
<p>3、标记-整理</p>
<p>该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现++将可回收对象移动到一端，然后清除掉端边界以外的对象++，这样就不会产生内存碎片了。</p>
<p>4、分代收集</p>
<p>现在的虚拟机垃圾收集大多采用这种方式，它++根据对象的生存周期，将堆分为新生代和老年代。++</p>
<p>在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类从加载进内存到卸载出内存为止，一共经历7个阶段： </p>
<p>加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化——&gt;<em>使用——&gt;卸载</em></p>
<p>其中，类加载包括5个阶段：<br>加载——&gt;验证——&gt;准备——&gt;解析——&gt;初始化</p>
<p>在类加载的过程中，以下3个过程称为连接：<br>验证——&gt;准备——&gt;解析</p>
<p>因此，JVM的类加载过程也可以概括为3个过程：<br>加载——&gt;连接——&gt;初始化</p>
<p>我们已经知道，类加载的过程包括：加载、连接、初始化，连接又分为：验证、准备、解析，所以说类加载一共分为5步：++加载、验证、准备、解析、初始化++。</p>
<p>其中加载、验证、准备、初始化的开始顺序是依次进行的，这些步骤开始之后的过程可能会有重叠。<br>而解析过程会发生在初始化过程中。</p>
<h3 id="类加载过程中“初始化”开始的时机"><a href="#类加载过程中“初始化”开始的时机" class="headerlink" title="类加载过程中“初始化”开始的时机"></a>类加载过程中“初始化”开始的时机</h3><ol>
<li>在运行过程中遇到如下字节码指令时，如果类尚未初始化，那就要进行初始化：new、getstatic、putstatic、invokestatic。这四个指令对应的Java代码场景是：<br>通过new创建对象；<br>读取、设置一个类的静态成员变量(不包括final修饰的静态变量)；<br>调用一个类的静态成员函数。</li>
<li>使用java.lang.reflect进行反射调用的时候，如果类没有初始化，那就需要初始化；</li>
<li>当初始化一个类的时候，若其父类尚未初始化，那就先要让其父类初始化，然后再初始化本类；<br>当虚拟机启动时，虚拟机会首先初始化带有main方法的类，即主类； </li>
</ol>
<p>JVM规范中要求在程序运行过程中，“当且仅当”出现上述4个条件之一的情况才会初始化一个类。如果间接满足上述初始化条件是不会初始化类的。</p>
<p>其中，直接满足上述初始化条件的情况叫做++主动引用++；间接满足上述初始化过程的情况叫做++被动引用++。<br>那么，只有当程序在运行过程中满足主动引用的时候才会初始化一个类，若满足被动引用就不会初始化一个类。 </p>
<p>接口的初始化：</p>
<p>接口和类都需要初始化，接口和类的初始化过程基本一样，不同点在于：类初始化时，如果发现父类尚未被初始化，则先要初始化父类，然后再初始化自己；但接口初始化时，并不要求父接口已经全部初始化，只有程序在运行过程中用到当父接口中的东西时才初始化父接口。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>注意：“加载”是“类加载”过程的第一步，千万不要混淆。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>在加载过程中，JVM主要做3件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取这个类的二进制字节流，即class文件： </p>
<p> 在程序运行过程中，当要访问一个类时，若发现这个类尚未被加载，并满足类初始化时机的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程。</p>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li><p>在内存中创建一个java.lang.Class类型的对象：</p>
<p> 接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个Class类型的类对象是提供给外界访问该类的接口。</p>
</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段比较耗时，它非常重要但不一定必要，如果所运行的代码已经被反复使用和验证过，那么可以使用-Xverify:none参数关闭，以缩短类加载时间。</p>
<ul>
<li>验证的目的是什么？</li>
</ul>
<p>验证是为了保证二进制字节流中的信息符合虚拟机规范，并没有安全问题。</p>
<ul>
<li>验证的过程</li>
</ul>
<ol>
<li><p>文件格式验证 </p>
<p> 这个阶段主要验证输入的二进制字节流是否符合class文件结构的规范。<br> 二进制字节流只有通过了本阶段的验证，才会被允许存入到方法区中。 </p>
<p> 本验证阶段是基于二进制字节流的，而后面的三个验证阶段都是在方法区中进行，并基于类特定的数据结构的。 </p>
<p> 通过上文可知，加载开始前，二进制字节流还没进方法区，而加载完成后，二进制字节流已经存入方法区。而在文件格式验证前，二进制字节流尚未进入方法区，文件格式验证通过之后才进入方法区。也就是说，++加载开始后，立即启动了文件格式验证，本阶段验证通过后，二进制字节流被转换成特定数据结构存储至方法区中++，继而开始下阶段的验证和创建Class对象等操作。</p>
<pre><code>这个过程印证了：加载和验证是交叉进行的。
</code></pre></li>
<li><p>元数据验证 </p>
<p> 本阶段对方法区中的++字节码描述信息++进行语义分析，确保其符合Java语法规范。</p>
</li>
<li><p>字节码验证 </p>
<p> 本阶段是验证过程的最复杂的一个阶段。<br>本阶段对++方法体++进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。</p>
</li>
<li><p>符号引用验证 </p>
<p> 本阶段验证发生在++解析阶段++，确保解析能正常执行。 </p>
</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段完成两件事情：</p>
<ol>
<li><p>为已经在方法区中的类中的静态成员变量分配内存</p>
<pre><code>类的静态成员变量也存储在方法区中。 
</code></pre></li>
<li><p>为静态成员变量设置初始值</p>
<pre><code>初始值为0、false、null等。
</code></pre></li>
</ol>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。 </p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是执行类构造器clinit()的过程。 </p>
<p>clinit()方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。</p>
<p>初始化过程的注意点</p>
<ul>
<li>clinit()方法中静态成员变量的赋值顺序是根据Java代码中成员变量的出现的顺序决定的。</li>
<li>构造函数init()需要显示调用父类构造函数，而类的构造函数clinit()不需要调用父类的类构造函数，因为虚拟机会确保子类的clinit()方法执行前已经执行了父类的clinit()方法。</li>
<li>如果一个类/接口中没有静态代码块，也没有静态成员变量的赋值操作，那么编译器就不会生成clinit()方法。</li>
<li>接口也需要通过clinit()方法为接口中定义的静态成员变量显示初始化。</li>
<li>接口中不能使用静态代码块。</li>
<li>接口在执行clinit()方法前，虚拟机不会确保其父接口的clinit()方法被执行，只有当父接口中的静态成员变量被使用到时才会执行父接口的clinit()方法。</li>
<li>虚拟机会给clinit()方法加锁，因此当多条线程同时执行某一个类的clinit()方法时，只有一个方法会被执行，其它的方法都被阻塞。并且，只要有一个clinit()方法执行完，其它的clinit()方法就不会再被执行。因此，在同一个类加载器下，同一个类只会被初始化一次。</li>
</ul>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器的作用：</p>
<p>将class文件加载进JVM的方法区，并在方法区中创建一个java.lang.Class对象作为外界访问这个类的接口。</p>
<p>类与类加载器的关系：</p>
<p>比较两个类是否相等，只有当这两个类由同一个加载器加载才有意义；否则，即使同一个class文件被不同的类加载器加载，那这两个类必定不同，即通过类的Class对象的equals执行的结果必为false。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/28/数据库学习/" rel="next" title="数据库学习">
                <i class="fa fa-chevron-left"></i> 数据库学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/28/mybatis学习整理/" rel="prev" title="mybatis学习整理">
                mybatis学习整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM内存模型"><span class="nav-number">1.</span> <span class="nav-text">JVM内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java堆"><span class="nav-number">1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何判定哪些对象需要回收（判断一个对象是否存活）？"><span class="nav-number">2.1.</span> <span class="nav-text">如何判定哪些对象需要回收（判断一个对象是否存活）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收无效对象的过程"><span class="nav-number">2.2.</span> <span class="nav-text">回收无效对象的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集的方法有哪些"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾收集的方法有哪些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载"><span class="nav-number">3.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的生命周期"><span class="nav-number">3.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载过程中“初始化”开始的时机"><span class="nav-number">3.2.</span> <span class="nav-text">类加载过程中“初始化”开始的时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的过程"><span class="nav-number">4.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载"><span class="nav-number">4.0.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证"><span class="nav-number">4.0.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备"><span class="nav-number">4.0.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析"><span class="nav-number">4.0.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">4.0.5.</span> <span class="nav-text">初始化</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#类与类加载器"><span class="nav-number">5.</span> <span class="nav-text">类与类加载器</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
